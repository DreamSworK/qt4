<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qt 4.8: QSharedPointer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="qt_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qt 4.8
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classQSharedPointer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">QSharedPointer&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> class holds a strong reference to a shared pointer.
 <a href="classQSharedPointer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qsharedpointer_8h_source.html">qsharedpointer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Functions</h2></td></tr>
<tr class="memitem:a4ce6a36a6392300aca4de14da5ba386d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a4ce6a36a6392300aca4de14da5ba386d">clear</a> ()</td></tr>
<tr class="memdesc:a4ce6a36a6392300aca4de14da5ba386d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object, dropping the reference that it may have had to the pointer.  <a href="#a4ce6a36a6392300aca4de14da5ba386d">More...</a><br /></td></tr>
<tr class="separator:a4ce6a36a6392300aca4de14da5ba386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7f60c5fada71bef9eb692bc6ac6d1f"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a3a7f60c5fada71bef9eb692bc6ac6d1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a3a7f60c5fada71bef9eb692bc6ac6d1f">constCast</a> () const</td></tr>
<tr class="memdesc:a3a7f60c5fada71bef9eb692bc6ac6d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a <code>const_cast</code> from this pointer's type to <code>X</code> and returns a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that shares the reference.  <a href="#a3a7f60c5fada71bef9eb692bc6ac6d1f">More...</a><br /></td></tr>
<tr class="separator:a3a7f60c5fada71bef9eb692bc6ac6d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c6c36ef56fcbb1540301f5cb8610e5"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a11c6c36ef56fcbb1540301f5cb8610e5">data</a> () const</td></tr>
<tr class="memdesc:a11c6c36ef56fcbb1540301f5cb8610e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the pointer referenced by this object.  <a href="#a11c6c36ef56fcbb1540301f5cb8610e5">More...</a><br /></td></tr>
<tr class="separator:a11c6c36ef56fcbb1540301f5cb8610e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5967363a757af57f3dd4fe0e60f1c5"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:aba5967363a757af57f3dd4fe0e60f1c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#aba5967363a757af57f3dd4fe0e60f1c5">dynamicCast</a> () const</td></tr>
<tr class="memdesc:aba5967363a757af57f3dd4fe0e60f1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a dynamic cast from this pointer's type to <code>X</code> and returns a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that shares the reference.  <a href="#aba5967363a757af57f3dd4fe0e60f1c5">More...</a><br /></td></tr>
<tr class="separator:aba5967363a757af57f3dd4fe0e60f1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af0112d2006146a9dfeda7471b32125"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a0af0112d2006146a9dfeda7471b32125">isNull</a> () const</td></tr>
<tr class="memdesc:a0af0112d2006146a9dfeda7471b32125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is holding a reference to a null pointer.  <a href="#a0af0112d2006146a9dfeda7471b32125">More...</a><br /></td></tr>
<tr class="separator:a0af0112d2006146a9dfeda7471b32125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b65ff3e66fa452957accf732506034"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a23b65ff3e66fa452957accf732506034"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a23b65ff3e66fa452957accf732506034">objectCast</a> () const</td></tr>
<tr class="memdesc:a23b65ff3e66fa452957accf732506034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a <a class="el" href="qobject_8h.html#a3c5dd82b5bd9f2b683e490f8d26d8caa">qobject_cast()</a> from this pointer's type to <code>X</code> and returns a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that shares the reference.  <a href="#a23b65ff3e66fa452957accf732506034">More...</a><br /></td></tr>
<tr class="separator:a23b65ff3e66fa452957accf732506034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6f179fb845f218dba6cd149f1756c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#abf6f179fb845f218dba6cd149f1756c8">operator bool</a> () const</td></tr>
<tr class="memdesc:abf6f179fb845f218dba6cd149f1756c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is not null.  <a href="#abf6f179fb845f218dba6cd149f1756c8">More...</a><br /></td></tr>
<tr class="separator:abf6f179fb845f218dba6cd149f1756c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b81a12a8a63192af9c3d1a25d170e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#ad4b81a12a8a63192af9c3d1a25d170e9">operator!</a> () const</td></tr>
<tr class="memdesc:ad4b81a12a8a63192af9c3d1a25d170e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is null.  <a href="#ad4b81a12a8a63192af9c3d1a25d170e9">More...</a><br /></td></tr>
<tr class="separator:ad4b81a12a8a63192af9c3d1a25d170e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6f14591279c48fb07784eb0122b164"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a1f6f14591279c48fb07784eb0122b164">operator*</a> () const</td></tr>
<tr class="memdesc:a1f6f14591279c48fb07784eb0122b164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the shared pointer's members.  <a href="#a1f6f14591279c48fb07784eb0122b164">More...</a><br /></td></tr>
<tr class="separator:a1f6f14591279c48fb07784eb0122b164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dcc0dce11d30992181bb9fdd62c666"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#aa3dcc0dce11d30992181bb9fdd62c666">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:aa3dcc0dce11d30992181bb9fdd62c666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the shared pointer's members.  <a href="#aa3dcc0dce11d30992181bb9fdd62c666">More...</a><br /></td></tr>
<tr class="separator:aa3dcc0dce11d30992181bb9fdd62c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278861fe61be0df2325f2b721a88602c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a278861fe61be0df2325f2b721a88602c">operator=</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a278861fe61be0df2325f2b721a88602c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this object share <em>other's</em> pointer.  <a href="#a278861fe61be0df2325f2b721a88602c">More...</a><br /></td></tr>
<tr class="separator:a278861fe61be0df2325f2b721a88602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641b54a53c877dd02adb05c428ac7692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a641b54a53c877dd02adb05c428ac7692">operator=</a> (const <a class="el" href="classQWeakPointer.html">QWeakPointer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a641b54a53c877dd02adb05c428ac7692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes <em>other</em> to a strong reference and makes this object share a reference to the pointer referenced by it.  <a href="#a641b54a53c877dd02adb05c428ac7692">More...</a><br /></td></tr>
<tr class="separator:a641b54a53c877dd02adb05c428ac7692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f33c4a18b7789f735f3fc3e4bf8beff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a9f33c4a18b7789f735f3fc3e4bf8beff">QSharedPointer</a> ()</td></tr>
<tr class="memdesc:a9f33c4a18b7789f735f3fc3e4bf8beff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that points to null (0).  <a href="#a9f33c4a18b7789f735f3fc3e4bf8beff">More...</a><br /></td></tr>
<tr class="separator:a9f33c4a18b7789f735f3fc3e4bf8beff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad530d120aac9ef83bd5b43aa765024f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#ad530d120aac9ef83bd5b43aa765024f8">QSharedPointer</a> (T *<a class="el" href="qdirectfbpaintengine_8cpp.html#ae34162c2bbf9e447cd557f139204b5e8">ptr</a>)</td></tr>
<tr class="memdesc:ad530d120aac9ef83bd5b43aa765024f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that points to <em>ptr</em>.  <a href="#ad530d120aac9ef83bd5b43aa765024f8">More...</a><br /></td></tr>
<tr class="separator:ad530d120aac9ef83bd5b43aa765024f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1567dd1c3eb4417f63f98deb5ed687c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#ae1567dd1c3eb4417f63f98deb5ed687c">QSharedPointer</a> (T *<a class="el" href="qdirectfbpaintengine_8cpp.html#ae34162c2bbf9e447cd557f139204b5e8">ptr</a>, Deleter <a class="el" href="qnumeric__p_8h.html#a873684cefeb665f3d5e6b495de57fc0d">d</a>)</td></tr>
<tr class="memdesc:ae1567dd1c3eb4417f63f98deb5ed687c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that points to <em>ptr</em>.  <a href="#ae1567dd1c3eb4417f63f98deb5ed687c">More...</a><br /></td></tr>
<tr class="separator:ae1567dd1c3eb4417f63f98deb5ed687c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912e0db8ffda47ba6d39e99ce7a98bab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a912e0db8ffda47ba6d39e99ce7a98bab">QSharedPointer</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a912e0db8ffda47ba6d39e99ce7a98bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object that shares <em>other's</em> pointer.  <a href="#a912e0db8ffda47ba6d39e99ce7a98bab">More...</a><br /></td></tr>
<tr class="separator:a912e0db8ffda47ba6d39e99ce7a98bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231f7435464062e379a90fc2d965c321"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a231f7435464062e379a90fc2d965c321">QSharedPointer</a> (const <a class="el" href="classQWeakPointer.html">QWeakPointer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a231f7435464062e379a90fc2d965c321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> by promoting the weak reference <em>other</em> to strong reference and sharing its pointer.  <a href="#a231f7435464062e379a90fc2d965c321">More...</a><br /></td></tr>
<tr class="separator:a231f7435464062e379a90fc2d965c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e188eb3279ef66efad6353096324eae"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a2e188eb3279ef66efad6353096324eae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a2e188eb3279ef66efad6353096324eae">staticCast</a> () const</td></tr>
<tr class="memdesc:a2e188eb3279ef66efad6353096324eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a static cast from this pointer's type to <code>X</code> and returns a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that shares the reference.  <a href="#a2e188eb3279ef66efad6353096324eae">More...</a><br /></td></tr>
<tr class="separator:a2e188eb3279ef66efad6353096324eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ed75c4ae4d58c767b89ca7c37699d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQWeakPointer.html">QWeakPointer</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a99ed75c4ae4d58c767b89ca7c37699d6">toWeakRef</a> () const</td></tr>
<tr class="memdesc:a99ed75c4ae4d58c767b89ca7c37699d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a weak reference object that shares the pointer referenced by this object.  <a href="#a99ed75c4ae4d58c767b89ca7c37699d6">More...</a><br /></td></tr>
<tr class="separator:a99ed75c4ae4d58c767b89ca7c37699d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4387510e07ec872409638e3377c0ba37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a4387510e07ec872409638e3377c0ba37">~QSharedPointer</a> ()</td></tr>
<tr class="memdesc:a4387510e07ec872409638e3377c0ba37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object.  <a href="#a4387510e07ec872409638e3377c0ba37">More...</a><br /></td></tr>
<tr class="separator:a4387510e07ec872409638e3377c0ba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a69eacc1068fba08ee35e94e1961a6610"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a69eacc1068fba08ee35e94e1961a6610">operator!=</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;ptr1, const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; &amp;ptr2)</td></tr>
<tr class="memdesc:a69eacc1068fba08ee35e94e1961a6610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pointer referenced by <em>ptr1</em> is not the same pointer as that referenced by <em>ptr2</em>.  <a href="#a69eacc1068fba08ee35e94e1961a6610">More...</a><br /></td></tr>
<tr class="separator:a69eacc1068fba08ee35e94e1961a6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae905fba3e66c6b9e46f87114100eb052"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#ae905fba3e66c6b9e46f87114100eb052">operator!=</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;ptr1, const X *ptr2)</td></tr>
<tr class="separator:ae905fba3e66c6b9e46f87114100eb052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058f23bfbcacdcfef12be4361681a84b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a058f23bfbcacdcfef12be4361681a84b">operator!=</a> (const T *ptr1, const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; &amp;ptr2)</td></tr>
<tr class="separator:a058f23bfbcacdcfef12be4361681a84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe343753dbedf31bf954d5c94896822"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a6fe343753dbedf31bf954d5c94896822">operator==</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;ptr1, const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; &amp;ptr2)</td></tr>
<tr class="memdesc:a6fe343753dbedf31bf954d5c94896822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pointer referenced by <em>ptr1</em> is the same pointer as that referenced by <em>ptr2</em>.  <a href="#a6fe343753dbedf31bf954d5c94896822">More...</a><br /></td></tr>
<tr class="separator:a6fe343753dbedf31bf954d5c94896822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f12fb7427fff7a0fb1226997feae9da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a6f12fb7427fff7a0fb1226997feae9da">operator==</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;ptr1, const X *ptr2)</td></tr>
<tr class="separator:a6f12fb7427fff7a0fb1226997feae9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5148c543fc7aa39920e60488672271d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#ab5148c543fc7aa39920e60488672271d">operator==</a> (const T *ptr1, const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; &amp;ptr2)</td></tr>
<tr class="separator:ab5148c543fc7aa39920e60488672271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19b48288678efcd40caf9fd888bae67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#ad19b48288678efcd40caf9fd888bae67">qSharedPointerCast</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ad19b48288678efcd40caf9fd888bae67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to the pointer held by <em>other</em>, cast to type <code>X</code>.  <a href="#ad19b48288678efcd40caf9fd888bae67">More...</a><br /></td></tr>
<tr class="separator:ad19b48288678efcd40caf9fd888bae67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28170b45f90c567a4f033f2db54cfd20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a28170b45f90c567a4f033f2db54cfd20">qSharedPointerConstCast</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a28170b45f90c567a4f033f2db54cfd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to the pointer held by <em>other</em>, cast to type <code>X</code>.  <a href="#a28170b45f90c567a4f033f2db54cfd20">More...</a><br /></td></tr>
<tr class="separator:a28170b45f90c567a4f033f2db54cfd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e304543bf465355281635c41bb9a542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#a1e304543bf465355281635c41bb9a542">qSharedPointerDynamicCast</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a1e304543bf465355281635c41bb9a542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to the pointer held by <em>other</em>, using a dynamic cast to type <code>X</code> to obtain an internal pointer of the appropriate type.  <a href="#a1e304543bf465355281635c41bb9a542">More...</a><br /></td></tr>
<tr class="separator:a1e304543bf465355281635c41bb9a542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf22b379b0a44fa2890afc1b4efbd19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQSharedPointer.html#abcf22b379b0a44fa2890afc1b4efbd19">qSharedPointerObjectCast</a> (const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:abcf22b379b0a44fa2890afc1b4efbd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The qSharedPointerObjectCast function is for casting a shared pointer.  <a href="#abcf22b379b0a44fa2890afc1b4efbd19">More...</a><br /></td></tr>
<tr class="separator:abcf22b379b0a44fa2890afc1b4efbd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class QSharedPointer&lt; T &gt;</h3>

<p>The <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> class holds a strong reference to a shared pointer. </p>
<dl class="section since"><dt>Since</dt><dd>4.5</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This class or function is <b>reentrant</b>.</dd></dl>
<p>The <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> is an automatic, shared pointer in C++. It behaves exactly like a normal pointer for normal purposes, including respect for constness.</p>
<p><a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will delete the pointer it is holding when it goes out of scope, provided no other <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> objects are referencing it.</p>
<p>A <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object can be created from a normal pointer, another <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object or by promoting a <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a> object to a strong reference.</p>
<p><a class="anchor" id="Thread-Safety"></a></p><h3>Thread-Safety</h3>
<p><a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> and <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a> are thread-safe and operate atomically on the pointer value. Different threads can also access the <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> or <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a> pointing to the same object at the same time without need for locking mechanisms.</p>
<p>It should be noted that, while the pointer value can be accessed in this manner, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> and <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a> provide no guarantee about the object being pointed to. Thread-safety and reentrancy rules for that object still apply.</p>
<p><a class="anchor" id="Other-Pointer-Classes"></a></p><h3>Other Pointer Classes</h3>
<p><a class="el" href="namespaceQt.html">Qt</a> also provides two other pointer wrapper classes: <a class="el" href="classQPointer.html" title="The QPointer class is a template class that provides guarded pointers to QObject. ...">QPointer</a> and <a class="el" href="classQSharedDataPointer.html" title="The QSharedDataPointer class represents a pointer to an implicitly shared object. ...">QSharedDataPointer</a>. They are incompatible with one another, since each has its very different use case.</p>
<p><a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> holds a shared pointer by means of an external reference count (i.e., a reference counter placed outside the object). Like its name indicates, the pointer value is shared among all instances of <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> and <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a>. The contents of the object pointed to by the pointer should not be considered shared, however: there is only one object. For that reason, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> does not provide a way to detach or make copies of the pointed object.</p>
<p><a class="el" href="classQSharedDataPointer.html" title="The QSharedDataPointer class represents a pointer to an implicitly shared object. ...">QSharedDataPointer</a>, on the other hand, holds a pointer to shared data (i.e., a class derived from <a class="el" href="classQSharedData.html" title="The QSharedData class is a base class for shared data objects. ">QSharedData</a>). It does so by means of an internal reference count, placed in the <a class="el" href="classQSharedData.html" title="The QSharedData class is a base class for shared data objects. ">QSharedData</a> base class. This class can, therefore, detach based on the type of access made to the data being guarded: if it's a non-const access, it creates a copy atomically for the operation to complete.</p>
<p><a class="el" href="classQExplicitlySharedDataPointer.html" title="The QExplicitlySharedDataPointer class represents a pointer to an explicitly shared object...">QExplicitlySharedDataPointer</a> is a variant of <a class="el" href="classQSharedDataPointer.html" title="The QSharedDataPointer class represents a pointer to an implicitly shared object. ...">QSharedDataPointer</a>, except that it only detaches if <a class="el" href="classQExplicitlySharedDataPointer.html#ad17d30dc655a31ff79d693279d652615" title="If the shared data object&#39;s reference count is greater than 1, this function creates a deep copy of t...">QExplicitlySharedDataPointer::detach()</a> is explicitly called (hence the name).</p>
<p><a class="el" href="classQScopedPointer.html" title="The QScopedPointer class stores a pointer to a dynamically allocated object, and deletes it upon dest...">QScopedPointer</a> simply holds a pointer to a heap allocated object and deletes it in its destructor. This class is useful when an object needs to be heap allocated and deleted, but no more. <a class="el" href="classQScopedPointer.html" title="The QScopedPointer class stores a pointer to a dynamically allocated object, and deletes it upon dest...">QScopedPointer</a> is lightweight, it makes no use of additional structure or reference counting.</p>
<p>Finally, <a class="el" href="classQPointer.html" title="The QPointer class is a template class that provides guarded pointers to QObject. ...">QPointer</a> holds a pointer to a QObject-derived object, but it does so weakly. <a class="el" href="classQPointer.html" title="The QPointer class is a template class that provides guarded pointers to QObject. ...">QPointer</a> can be replaced by <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a> in almost all cases, since they have the same functionality. See <a href="classQWeakPointer.html#tracking-qobject">QWeakPointers tracking a QObject</a> for more information.</p>
<p><a class="anchor" id="Optional-pointer-tracking"></a></p><h3>Optional pointer tracking</h3>
<p>A feature of <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that can be enabled at compile time for debugging purposes is a pointer tracking mechanism. When enabled, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> registers in a global set all the pointers that it tracks. This allows one to catch mistakes like assigning the same pointer to two <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> objects.</p>
<p>This function is enabled by defining the <code>QT_SHAREDPOINTER_TRACK_POINTERS</code> macro before including the <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> header.</p>
<p>It is safe to use this feature even with code compiled without the feature. <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will ensure that the pointer is removed from the tracker even from code compiled without pointer tracking.</p>
<p>Note, however, that the pointer tracking feature has limitations on multiple- or virtual-inheritance (that is, in cases where two different pointer addresses can refer to the same object). In that case, if a pointer is cast to a different type and its value changes, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a>'s pointer tracking mechanism may fail to detect that the object being tracked is the same.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is not part of the public interface. <a class="anchor" id="QSharedPointer-internals"></a><h3><a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> internals</h3>
</dd></dl>
<p><a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> is in reality implemented by two ancestor classes: QtSharedPointer::Basic and QtSharedPointer::ExternalRefCount. The reason for having that split is now mostly legacy: in the beginning, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> was meant to support both internal reference counting and external reference counting.</p>
<p>QtSharedPointer::Basic implements the basic functionality that is shared between internal- and external-reference counting. That is, it's mostly the accessor functions into <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a>. Those are all inherited by <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a>, which adds another level of shared functionality (the constructors and assignment operators). The Basic class has one member variable, which is the actual pointer being tracked.</p>
<p>QtSharedPointer::ExternalRefCount implements the actual reference counting and introduces the d-pointer for <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a>. That d-pointer itself is shared with other <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> objects as well as <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a>.</p>
<p>The reason for keeping the pointer value itself outside the d-pointer is because of multiple inheritance needs. If you have two <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> objects of different pointer types, but pointing to the same object in memory, it could happen that the pointer values are different. The <code>differentPointers</code> autotest exemplifies this problem. The same thing could happen in the case of virtual inheritance: a pointer of class matching the virtual base has different address compared to the pointer of the complete object. See the <code>virtualBaseDifferentPointers</code> autotest for this problem.</p>
<p>The d pointer is of type QtSharedPointer::ExternalRefCountData for simple <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> objects, but could be of a derived type in some cases. It is basically a reference-counted reference-counter.</p>
<p><a class="anchor" id="d-pointer"></a></p><h4>d-pointer</h4>
<p><a class="anchor" id="QtSharedPointer"></a>::ExternalRefCountData </p><h5>QtSharedPointer::ExternalRefCountData</h5>
<p>This class is basically a reference-counted reference-counter. It has two members: <code>strongref</code> and <code>weakref</code>. The strong reference counter is controlling the lifetime of the object tracked by <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a>. a positive value indicates that the object is alive. It's also the number of QSharedObject instances that are attached to this Data.</p>
<p>When the strong reference count decreases to zero, the object is deleted (see below for information on custom deleters). The strong reference count can also exceptionally be -1, indicating that there are no QSharedPointers attached to an object, which is tracked too. The only case where this is possible is that of <a href="classQWeakPointer.html#tracking-qobject">QWeakPointers tracking a QObject</a>.</p>
<p>The weak reference count controls the lifetime of the d-pointer itself. It can be thought of as an internal/intrusive reference count for ExternalRefCountData itself. This count is equal to the number of QSharedPointers and QWeakPointers that are tracking this object. (In case the object tracked derives from <a class="el" href="classQObject.html" title="The QObject class is the base class of all Qt objects. ">QObject</a>, this number is increased by 1, since <a class="el" href="classQObjectPrivate.html">QObjectPrivate</a> tracks it too).</p>
<p>ExternalRefCountData is a virtual class: it has a virtual destructor and a virtual destroy() function. The destroy() function is supposed to delete the object being tracked and return true if it does so. Otherwise, it returns false to indicate that the caller must simply call delete. This allows the normal use-case of <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> without custom deleters to use only one 12- or 16-byte (depending on whether it's a 32- or 64-bit architecture) external descriptor structure, without paying the price for the custom deleter that it isn't using.</p>
<p><a class="anchor" id="QtSharedPointer"></a>::ExternalRefCountDataWithDestroyFn </p><h5>QtSharedPointer::ExternalRefCountDataWithDestroyFn</h5>
<p>This class is not used directly, per se. It only exists to enable the two classes that derive from it. It adds one member variable, which is a pointer to a function (which returns void and takes an ExternalRefCountData* as a parameter). It also overrides the destroy() function: it calls that function pointer with <code>this</code> as parameter, and returns true.</p>
<p>That means when ExternalRefCountDataWithDestroyFn is used, the <code>destroyer</code> field must be set to a valid function that <b>will</b> delete the object tracked.</p>
<p>This class also adds an operator delete function to ensure that it simply calls the global operator delete. That should be the behaviour in all compilers already, but to be on the safe side, this class ensures that no funny business happens.</p>
<p>On a 32-bit architecture, this class is 16 bytes in size, whereas it's 24 bytes on 64-bit. (On Itanium where function pointers contain the global pointer, it can be 32 bytes).</p>
<p><a class="anchor" id="QtSharedPointer"></a>::ExternalRefCountWithCustomDeleter </p><h5>QtSharedPointer::ExternalRefCountWithCustomDeleter</h5>
<p>This class derives from ExternalRefCountDataWithDestroyFn and is a template class. As template parameters, it has the type of the pointer being tracked (<code>T</code>) and a <code>Deleter</code>, which is anything. It adds two fields to its parent class, matching those template parameters: a member of type <code>Deleter</code> and a member of type <code>T*</code>.</p>
<p>The purpose of this class is to store the pointer to be deleted and the deleter code along with the d-pointer. This allows the last strong reference to call any arbitrary function that disposes of the object. For example, this allows calling <a class="el" href="classQObject.html#af6982f45bdad0833b8f3ee5688cccbfb" title="Schedules this object for deletion. ">QObject::deleteLater()</a> on a given object. The pointer to the object is kept here to avoid the extra cost of keeping the deleter in the generic case.</p>
<p>This class is never instantiated directly: the constructors and destructor are private. Only the <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">create()</a> function may be called to return an object of this type. See below for construction details.</p>
<p>The size of this class depends on the size of <code>Deleter</code>. If it's an empty functor (i.e., no members), ABIs generally assign it the size of 1. But given that it's followed by a pointer, up to 3 or 7 padding bytes may be inserted: in that case, the size of this class is 16+4+4 = 24 bytes on 32-bit architectures, or 24+8+8 = 40 bytes on 64-bit architectures (48 bytes on Itanium with global pointers stored). If <code>Deleter</code> is a function pointer, the size should be the same as the empty structure case, except for Itanium where it may be 56 bytes due to another global pointer. If <code>Deleter</code> is a pointer to a member function (PMF), the size will be even bigger and will depend on the ABI. For architectures using the Itanium C++ ABI, a PMF is twice the size of a normal pointer, or 24 bytes on Itanium itself. In that case, the size of this structure will be 16+8+4 = 28 bytes on 32-bit architectures, 24+16+8 = 48 bytes on 64-bit, and 32+24+8 = 64 bytes on Itanium.</p>
<p>(Values for Itanium consider an LP64 architecture; for ILP32, pointers are 32-bit in length, function pointers are 64-bit and PMF are 96-bit, so the sizes are slightly less)</p>
<p><a class="anchor" id="QtSharedPointer"></a>::ExternalRefCountWithContiguousData </p><h5>QtSharedPointer::ExternalRefCountWithContiguousData</h5>
<p>This class also derives from ExternalRefCountDataWithDestroyFn and it is also a template class. The template parameter is the type <code>T</code> of the class which <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> tracks. It adds only one member to its parent, which is of type <code>T</code> (the actual type, not a pointer to it).</p>
<p>The purpose of this class is to lay the <code>T</code> object out next to the reference counts, saving one memory allocation per shared pointer. This is particularly interesting for small <code>T</code> or for the cases when there are few if any <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a> tracking the object. This class exists to implement the <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">QSharedPointer::create()</a> call.</p>
<p>Like ExternalRefCountWithCustomDeleter, this class is never instantiated directly. This class also provides a <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">create()</a> member that returns the pointer, and hides its constructors and destructor. (With C++0x, we'd delete them).</p>
<p>The size of this class depends on the size of <code>T</code>.</p>
<p><a class="anchor" id="Instantiating-ExternalRefCountWithCustomDeleter-and-ExternalRefCountWithContiguousData"></a></p><h5>Instantiating ExternalRefCountWithCustomDeleter and ExternalRefCountWithContiguousData</h5>
<p>Like explained above, these classes have private constructors. Moreover, they are not defined anywhere, so trying to call <code>new ClassType</code> would result in a compilation or linker error. Instead, these classes must be constructed via their <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">create()</a> methods.</p>
<p>Instead of instantiating the class by the normal way, the <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">create()</a> method calls <code>operator new</code> directly with the size of the class, then calls the parent class's constructor only (ExternalRefCountDataWithDestroyFn). This ensures that the inherited members are initialised properly, as well as the virtual table pointer, which must point to ExternalRefCountDataWithDestroyFn's virtual table. That way, we also ensure that the virtual destructor being called is ExternalRefCountDataWithDestroyFn's.</p>
<p>After initialising the base class, the <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">ExternalRefCountWithCustomDeleter::create()</a> function initialises the new members directly, by using the placement <code>operator new</code>. In the case of the <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">ExternalRefCountWithContiguousData::create()</a> function, the address to the still-uninitialised <code>T</code> member is saved for the callee to use. The member is only initialised in <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">QSharedPointer::create()</a>, so that we avoid having many variants of the internal functions according to the arguments in use for calling the constructor.</p>
<p>When initialising the parent class, the <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">create()</a> functions pass the address of the static deleter() member function. That is, when the virtual destroy() is called by <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a>, the deleter() functions are called instead. These functions static_cast the ExternalRefCountData* parameter to their own type and execute their deletion: for the ExternalRefCountWithCustomDeleter::deleter() case, it runs the user's custom deleter, then destroys the deleter; for ExternalRefCountWithContiguousData::deleter, it simply calls the <code>T</code> destructor directly.</p>
<p>By not calling the constructor of the derived classes, we avoid instantiating their virtual tables. Since these classes are template-based, there would be one virtual table per <code>T</code> and <code>Deleter</code> type. (This is what <a class="el" href="namespaceQt.html">Qt</a> 4.5 did.)</p>
<p>Instead, only one non-inline function is required per template, which is the deleter() static member. All the other functions can be inlined. What's more, the address of deleter() is calculated only in code, which can be resolved at link-time if the linker can determine that the function lies in the current application or library module (since these classes are not exported, that is the case for Windows or for builds with <code>-fvisibility=hidden</code>).</p>
<p>In contrast, a virtual table would require at least 3 relocations to be resolved at module load-time, per module where these classes are used. (In the Itanium C++ ABI, there would be more relocations, due to the RTTI)</p>
<p><a class="anchor" id="Modifications-due-to-pointer-tracking"></a></p><h5>Modifications due to pointer-tracking</h5>
<p>To ensure that pointers created with pointer-tracking enabled get un-tracked when destroyed, even if destroyed by code compiled without the feature, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> modifies slightly the instructions of the previous sections.</p>
<p>When ExternalRefCountWithCustomDeleter or ExternalRefCountWithContiguousData are used, their <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">create()</a> functions will set the ExternalRefCountDataWithDestroyFn::destroyer function pointer to safetyCheckDeleter() instead. These static member functions simply call internalSafetyCheckRemove2() before passing control to the normal deleter() function.</p>
<p>If neither custom deleter nor <a class="el" href="namespaceQPatternist.html#ae2cec3e98725791915467ebd2063d2cd">QSharedPointer::create()</a> are used, then <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> uses a custom deleter of its own: the normalDeleter() function, which simply calls <code>delete</code>. By using a custom deleter, the safetyCheckDeleter() procedure described above kicks in.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedDataPointer.html" title="The QSharedDataPointer class represents a pointer to an implicitly shared object. ...">QSharedDataPointer</a>, <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a>, <a class="el" href="classQScopedPointer.html" title="The QScopedPointer class stores a pointer to a dynamically allocated object, and deletes it upon dest...">QScopedPointer</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="qsharedpointer_8h_source.html#l00062">62</a> of file <a class="el" href="qsharedpointer_8h_source.html">qsharedpointer.h</a>.</p>
</div><h2 class="groupheader">Constructors and Destructors</h2>
<a id="a9f33c4a18b7789f735f3fc3e4bf8beff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f33c4a18b7789f735f3fc3e4bf8beff">&#9670;&nbsp;</a></span>QSharedPointer() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::<a class="el" href="classQSharedPointer.html">QSharedPointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that points to null (0). </p>

</div>
</div>
<a id="ad530d120aac9ef83bd5b43aa765024f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad530d120aac9ef83bd5b43aa765024f8">&#9670;&nbsp;</a></span>QSharedPointer() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::<a class="el" href="classQSharedPointer.html">QSharedPointer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that points to <em>ptr</em>. </p>
<p>The pointer <em>ptr</em> becomes managed by this <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> and must not be passed to another <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object or deleted outside this object. </p>

</div>
</div>
<a id="ae1567dd1c3eb4417f63f98deb5ed687c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1567dd1c3eb4417f63f98deb5ed687c">&#9670;&nbsp;</a></span>QSharedPointer() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::<a class="el" href="classQSharedPointer.html">QSharedPointer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that points to <em>ptr</em>. </p>
<p>The pointer <em>ptr</em> becomes managed by this <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> and must not be passed to another <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object or deleted outside this object.</p>
<p>The <em>deleter</em> parameter specifies the custom deleter for this object. The custom deleter is called, instead of the operator delete(), when the strong reference count drops to 0. This is useful, for instance, for calling deleteLater() on a <a class="el" href="classQObject.html" title="The QObject class is the base class of all Qt objects. ">QObject</a> instead:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="qsharednetworksession_8cpp.html#a8f3df97f7c24ad3c3c3e28d1aa0a15e0">doDeleteLater</a>(MyObject *obj)</div><div class="line">{</div><div class="line">    obj-&gt;deleteLater();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> otherFunction()</div><div class="line">{</div><div class="line">    <a class="code" href="classQSharedPointer.html">QSharedPointer&lt;MyObject&gt;</a> obj =</div><div class="line">        <a class="code" href="classQSharedPointer.html">QSharedPointer&lt;MyObject&gt;</a>(<span class="keyword">new</span> MyObject, <a class="code" href="qsharednetworksession_8cpp.html#a8f3df97f7c24ad3c3c3e28d1aa0a15e0">doDeleteLater</a>);</div><div class="line"></div><div class="line">    <span class="comment">// continue using obj</span></div><div class="line">    obj.<a class="code" href="classQSharedPointer.html#a4ce6a36a6392300aca4de14da5ba386d">clear</a>();    <span class="comment">// calls obj-&gt;deleteLater();</span></div><div class="line">}</div></div><!-- fragment --><p>It is also possible to specify a member function directly, as in: </p><div class="fragment"><div class="line"><a class="code" href="classQSharedPointer.html">QSharedPointer&lt;MyObject&gt;</a> obj =</div><div class="line">    <a class="code" href="classQSharedPointer.html">QSharedPointer&lt;MyObject&gt;</a>(<span class="keyword">new</span> MyObject, &amp;<a class="code" href="classQObject.html#af6982f45bdad0833b8f3ee5688cccbfb">QObject::deleteLater</a>);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a4ce6a36a6392300aca4de14da5ba386d" title="Clears this QSharedPointer object, dropping the reference that it may have had to the pointer...">clear()</a> </dd></dl>

</div>
</div>
<a id="a912e0db8ffda47ba6d39e99ce7a98bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912e0db8ffda47ba6d39e99ce7a98bab">&#9670;&nbsp;</a></span>QSharedPointer() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::<a class="el" href="classQSharedPointer.html">QSharedPointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object that shares <em>other's</em> pointer. </p>
<p>If <code>T</code> is a derived type of the template parameter of this class, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error. </p>

</div>
</div>
<a id="a231f7435464062e379a90fc2d965c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231f7435464062e379a90fc2d965c321">&#9670;&nbsp;</a></span>QSharedPointer() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::<a class="el" href="classQSharedPointer.html">QSharedPointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQWeakPointer.html">QWeakPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> by promoting the weak reference <em>other</em> to strong reference and sharing its pointer. </p>
<p>If <code>T</code> is a derived type of the template parameter of this class, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQWeakPointer.html#a4d5a35760e3fd709320b208ad521d71d" title="Promotes this weak reference to a strong one and returns a QSharedPointer object holding that referen...">QWeakPointer::toStrongRef()</a> </dd></dl>

</div>
</div>
<a id="a4387510e07ec872409638e3377c0ba37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4387510e07ec872409638e3377c0ba37">&#9670;&nbsp;</a></span>~QSharedPointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::~<a class="el" href="classQSharedPointer.html">QSharedPointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object. </p>
<p>If it is the last reference to the pointer stored, this will delete the pointer as well. </p>

<p class="definition">Definition at line <a class="el" href="qsharedpointer_8h_source.html#l00080">80</a> of file <a class="el" href="qsharedpointer_8h_source.html">qsharedpointer.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;{ }</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Functions</h2>
<a id="a4ce6a36a6392300aca4de14da5ba386d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce6a36a6392300aca4de14da5ba386d">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears this <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> object, dropping the reference that it may have had to the pointer. </p>
<p>If this was the last reference, then the pointer itself will be deleted. </p>

<p class="reference">Referenced by <a class="el" href="qsharedpointer_8h_source.html#l00080">QSharedPointer&lt; QNetworkSession &gt;::~QSharedPointer()</a>.</p>

</div>
</div>
<a id="a3a7f60c5fada71bef9eb692bc6ac6d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7f60c5fada71bef9eb692bc6ac6d1f">&#9670;&nbsp;</a></span>constCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::constCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a <code>const_cast</code> from this pointer's type to <code>X</code> and returns a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that shares the reference. </p>
<p>This function can be used for up- and for down-casting, but is more useful for up-casting.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a0af0112d2006146a9dfeda7471b32125" title="Returns true if this object is holding a reference to a null pointer. ">isNull()</a>, <a class="el" href="classQSharedPointer.html#a28170b45f90c567a4f033f2db54cfd20" title="Returns a shared pointer to the pointer held by other, cast to type X. ">qSharedPointerConstCast()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="qsharedpointer_8h_source.html#l00080">QSharedPointer&lt; QNetworkSession &gt;::~QSharedPointer()</a>.</p>

</div>
</div>
<a id="a11c6c36ef56fcbb1540301f5cb8610e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c6c36ef56fcbb1540301f5cb8610e5">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the pointer referenced by this object. </p>
<p>Note: do not delete the pointer returned by this function or pass it to another function that could delete it, including creating <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> or <a class="el" href="classQWeakPointer.html" title="The QWeakPointer class holds a weak reference to a shared pointer. ">QWeakPointer</a> objects. </p>

<p class="reference">Referenced by <a class="el" href="qnetworkaccessmanager_8cpp_source.html#l01296">QNetworkAccessManagerPrivate::_q_networkSessionClosed()</a>, <a class="el" href="qhostinfo_8cpp_source.html#l00286">QHostInfoPrivate::fromName()</a>, <a class="el" href="qnetworkaccesshttpbackend_8cpp_source.html#l00361">QNetworkAccessHttpBackend::postRequest()</a>, and <a class="el" href="qnetworkreplyimpl_8cpp_source.html#l00692">QNetworkReplyImplPrivate::setDownloadBuffer()</a>.</p>

</div>
</div>
<a id="aba5967363a757af57f3dd4fe0e60f1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5967363a757af57f3dd4fe0e60f1c5">&#9670;&nbsp;</a></span>dynamicCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::dynamicCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a dynamic cast from this pointer's type to <code>X</code> and returns a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that shares the reference. </p>
<p>If this function is used to up-cast, then <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will perform a <code>dynamic_cast</code>, which means that if the object being pointed by this <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> is not of type <code>X</code>, the returned object will be null.</p>
<p>Note: the template type <code>X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a class="el" href="classQSharedPointer.html#a3a7f60c5fada71bef9eb692bc6ac6d1f" title="Performs a const_cast from this pointer&#39;s type to X and returns a QSharedPointer that shares the refe...">constCast()</a> if you need to drop those qualifiers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a1e304543bf465355281635c41bb9a542" title="Returns a shared pointer to the pointer held by other, using a dynamic cast to type X to obtain an in...">qSharedPointerDynamicCast()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="qsharedpointer_8h_source.html#l00080">QSharedPointer&lt; QNetworkSession &gt;::~QSharedPointer()</a>.</p>

</div>
</div>
<a id="a0af0112d2006146a9dfeda7471b32125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af0112d2006146a9dfeda7471b32125">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this object is holding a reference to a null pointer. </p>

<p class="reference">Referenced by <a class="el" href="qhttpthreaddelegate_8cpp_source.html#l00569">QHttpThreadDelegate::dataReadProgressSlot()</a>, <a class="el" href="qsharednetworksession_8cpp_source.html#l00067">QSharedNetworkSessionManager::getSession()</a>, <a class="el" href="qhttpthreaddelegate_8cpp_source.html#l00375">QHttpThreadDelegate::readyReadSlot()</a>, <a class="el" href="qnetworkaccesshttpbackend_8cpp_source.html#l00775">QNetworkAccessHttpBackend::replyDownloadMetaData()</a>, and <a class="el" href="qdeclarativebinding_8cpp_source.html#l00179">QDeclarativeAbstractBinding::weakPointer()</a>.</p>

</div>
</div>
<a id="a23b65ff3e66fa452957accf732506034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b65ff3e66fa452957accf732506034">&#9670;&nbsp;</a></span>objectCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::objectCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a <a class="el" href="qobject_8h.html#a3c5dd82b5bd9f2b683e490f8d26d8caa">qobject_cast()</a> from this pointer's type to <code>X</code> and returns a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that shares the reference. </p>
<dl class="section since"><dt>Since</dt><dd>4.6</dd></dl>
<p>If this function is used to up-cast, then <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will perform a <code>qobject_cast</code>, which means that if the object being pointed by this <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> is not of type <code>X</code>, the returned object will be null.</p>
<p>Note: the template type <code>X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a class="el" href="classQSharedPointer.html#a3a7f60c5fada71bef9eb692bc6ac6d1f" title="Performs a const_cast from this pointer&#39;s type to X and returns a QSharedPointer that shares the refe...">constCast()</a> if you need to drop those qualifiers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#abcf22b379b0a44fa2890afc1b4efbd19" title="The qSharedPointerObjectCast function is for casting a shared pointer. ">qSharedPointerObjectCast()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="qsharedpointer_8h_source.html#l00080">QSharedPointer&lt; QNetworkSession &gt;::~QSharedPointer()</a>.</p>

</div>
</div>
<a id="abf6f179fb845f218dba6cd149f1756c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6f179fb845f218dba6cd149f1756c8">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this object is not null. </p>
<p>This function is suitable for use in <code>if-constructs</code>, like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (sharedptr) { ... }</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a0af0112d2006146a9dfeda7471b32125" title="Returns true if this object is holding a reference to a null pointer. ">isNull()</a> </dd></dl>

</div>
</div>
<a id="ad4b81a12a8a63192af9c3d1a25d170e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b81a12a8a63192af9c3d1a25d170e9">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this object is null. </p>
<p>This function is suitable for use in <code>if-constructs</code>, like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!sharedptr) { ... }</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a0af0112d2006146a9dfeda7471b32125" title="Returns true if this object is holding a reference to a null pointer. ">isNull()</a> </dd></dl>

</div>
</div>
<a id="a1f6f14591279c48fb07784eb0122b164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6f14591279c48fb07784eb0122b164">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the shared pointer's members. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a0af0112d2006146a9dfeda7471b32125" title="Returns true if this object is holding a reference to a null pointer. ">isNull()</a> </dd></dl>

</div>
</div>
<a id="aa3dcc0dce11d30992181bb9fdd62c666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dcc0dce11d30992181bb9fdd62c666">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the shared pointer's members. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a0af0112d2006146a9dfeda7471b32125" title="Returns true if this object is holding a reference to a null pointer. ">isNull()</a> </dd></dl>

</div>
</div>
<a id="a278861fe61be0df2325f2b721a88602c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278861fe61be0df2325f2b721a88602c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a> &amp; <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this object share <em>other's</em> pointer. </p>
<p>The current pointer reference is discarded and, if it was the last, the pointer will be deleted.</p>
<p>If <code>T</code> is a derived type of the template parameter of this class, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error. </p>

<p class="reference">Referenced by <a class="el" href="qsharedpointer_8h_source.html#l00080">QSharedPointer&lt; QNetworkSession &gt;::~QSharedPointer()</a>.</p>

</div>
</div>
<a id="a641b54a53c877dd02adb05c428ac7692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641b54a53c877dd02adb05c428ac7692">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a> &amp; <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQWeakPointer.html">QWeakPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes <em>other</em> to a strong reference and makes this object share a reference to the pointer referenced by it. </p>
<p>The current pointer reference is discarded and, if it was the last, the pointer will be deleted.</p>
<p>If <code>T</code> is a derived type of the template parameter of this class, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will perform an automatic cast. Otherwise, you will get a compiler error. </p>

</div>
</div>
<a id="a2e188eb3279ef66efad6353096324eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e188eb3279ef66efad6353096324eae">&#9670;&nbsp;</a></span>staticCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::staticCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a static cast from this pointer's type to <code>X</code> and returns a <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> that shares the reference. </p>
<p>This function can be used for up- and for down-casting, but is more useful for up-casting.</p>
<p>Note: the template type <code>X</code> must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use <a class="el" href="classQSharedPointer.html#a3a7f60c5fada71bef9eb692bc6ac6d1f" title="Performs a const_cast from this pointer&#39;s type to X and returns a QSharedPointer that shares the refe...">constCast()</a> if you need to drop those qualifiers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#aba5967363a757af57f3dd4fe0e60f1c5" title="Performs a dynamic cast from this pointer&#39;s type to X and returns a QSharedPointer that shares the re...">dynamicCast()</a>, <a class="el" href="classQSharedPointer.html#a3a7f60c5fada71bef9eb692bc6ac6d1f" title="Performs a const_cast from this pointer&#39;s type to X and returns a QSharedPointer that shares the refe...">constCast()</a>, <a class="el" href="classQSharedPointer.html#ad19b48288678efcd40caf9fd888bae67" title="Returns a shared pointer to the pointer held by other, cast to type X. ">qSharedPointerCast()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="qsharedpointer_8h_source.html#l00080">QSharedPointer&lt; QNetworkSession &gt;::~QSharedPointer()</a>.</p>

</div>
</div>
<a id="a99ed75c4ae4d58c767b89ca7c37699d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ed75c4ae4d58c767b89ca7c37699d6">&#9670;&nbsp;</a></span>toWeakRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQWeakPointer.html">QWeakPointer</a>&lt; T &gt; <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt;::toWeakRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a weak reference object that shares the pointer referenced by this object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQWeakPointer.html#a9939a856ca76b467358575ae56a59ad7" title="Creates a QWeakPointer that points to nothing. ">QWeakPointer::QWeakPointer()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="qnetworkaccessmanager_8cpp_source.html#l01247">QNetworkAccessManagerPrivate::createSession()</a>, <a class="el" href="qdeclarativebinding_8cpp_source.html#l00179">QDeclarativeAbstractBinding::weakPointer()</a>, and <a class="el" href="qsharedpointer_8h_source.html#l00080">QSharedPointer&lt; QNetworkSession &gt;::~QSharedPointer()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends and Related Functions</h2>
<a id="a69eacc1068fba08ee35e94e1961a6610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69eacc1068fba08ee35e94e1961a6610">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQSharedPointer.html#ad4b81a12a8a63192af9c3d1a25d170e9">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the pointer referenced by <em>ptr1</em> is not the same pointer as that referenced by <em>ptr2</em>. </p>
<p>If <em>ptr2's</em> template parameter is different from <em>ptr1's</em>, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <em>ptr2's</em> template parameter is not a base or a derived type from <em>ptr1's</em>, you will get a compiler error. </p>

</div>
</div>
<a id="ae905fba3e66c6b9e46f87114100eb052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae905fba3e66c6b9e46f87114100eb052">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQSharedPointer.html#ad4b81a12a8a63192af9c3d1a25d170e9">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the pointer referenced by <em>ptr1</em> is not the same pointer as <em>ptr2</em>.</p>
<p>If <em>ptr2's</em> type is different from <em>ptr1's</em>, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <em>ptr2's</em> type is not a base or a derived type from this <em>ptr1's</em>, you will get a compiler error. </p>

</div>
</div>
<a id="a058f23bfbcacdcfef12be4361681a84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058f23bfbcacdcfef12be4361681a84b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQSharedPointer.html#ad4b81a12a8a63192af9c3d1a25d170e9">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the pointer <em>ptr1</em> is not the same pointer as that referenced by <em>ptr2</em>.</p>
<p>If <em>ptr2's</em> template parameter is different from <em>ptr1's</em> type, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <em>ptr2's</em> template parameter is not a base or a derived type from <em>ptr1's</em> type, you will get a compiler error. </p>

</div>
</div>
<a id="a6fe343753dbedf31bf954d5c94896822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe343753dbedf31bf954d5c94896822">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the pointer referenced by <em>ptr1</em> is the same pointer as that referenced by <em>ptr2</em>. </p>
<p>If <em>ptr2's</em> template parameter is different from <em>ptr1's</em>, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <em>ptr2's</em> template parameter is not a base or a derived type from <em>ptr1's</em>, you will get a compiler error. </p>

</div>
</div>
<a id="a6f12fb7427fff7a0fb1226997feae9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f12fb7427fff7a0fb1226997feae9da">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the pointer referenced by <em>ptr1</em> is the same pointer as <em>ptr2</em>.</p>
<p>If <em>ptr2's</em> type is different from <em>ptr1's</em>, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <em>ptr2's</em> type is not a base or a derived type from this <em>ptr1's</em>, you will get a compiler error. </p>

</div>
</div>
<a id="ab5148c543fc7aa39920e60488672271d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5148c543fc7aa39920e60488672271d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the pointer <em>ptr1</em> is the same pointer as that referenced by <em>ptr2</em>.</p>
<p>If <em>ptr2's</em> template parameter is different from <em>ptr1's</em> type, <a class="el" href="classQSharedPointer.html" title="The QSharedPointer class holds a strong reference to a shared pointer. ">QSharedPointer</a> will attempt to perform an automatic <code>static_cast</code> to ensure that the pointers being compared are equal. If <em>ptr2's</em> template parameter is not a base or a derived type from <em>ptr1's</em> type, you will get a compiler error. </p>

</div>
</div>
<a id="ad19b48288678efcd40caf9fd888bae67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19b48288678efcd40caf9fd888bae67">&#9670;&nbsp;</a></span>qSharedPointerCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; qSharedPointerCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a shared pointer to the pointer held by <em>other</em>, cast to type <code>X</code>. </p>
<p>The types <code>T</code> and <code>X</code> must belong to one hierarchy for the <code>static_cast</code> to succeed.</p>
<p>Note that <code>X</code> must have the same cv-qualifiers (<code>const</code> and <code>volatile</code>) that <code>T</code> has, or the code will fail to compile. Use qSharedPointerConstCast to cast away the constness.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a2e188eb3279ef66efad6353096324eae" title="Performs a static cast from this pointer&#39;s type to X and returns a QSharedPointer that shares the ref...">QSharedPointer::staticCast()</a>, <a class="el" href="classQSharedPointer.html#a1e304543bf465355281635c41bb9a542" title="Returns a shared pointer to the pointer held by other, using a dynamic cast to type X to obtain an in...">qSharedPointerDynamicCast()</a>, <a class="el" href="classQSharedPointer.html#a28170b45f90c567a4f033f2db54cfd20" title="Returns a shared pointer to the pointer held by other, cast to type X. ">qSharedPointerConstCast()</a> </dd></dl>

</div>
</div>
<a id="a28170b45f90c567a4f033f2db54cfd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28170b45f90c567a4f033f2db54cfd20">&#9670;&nbsp;</a></span>qSharedPointerConstCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; qSharedPointerConstCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a shared pointer to the pointer held by <em>other</em>, cast to type <code>X</code>. </p>
<p>The types <code>T</code> and <code>X</code> must belong to one hierarchy for the <code>const_cast</code> to succeed. The <code>const</code> and <code>volatile</code> differences between <code>T</code> and <code>X</code> are ignored.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a3a7f60c5fada71bef9eb692bc6ac6d1f" title="Performs a const_cast from this pointer&#39;s type to X and returns a QSharedPointer that shares the refe...">QSharedPointer::constCast()</a>, <a class="el" href="classQSharedPointer.html#ad19b48288678efcd40caf9fd888bae67" title="Returns a shared pointer to the pointer held by other, cast to type X. ">qSharedPointerCast()</a>, <a class="el" href="classQSharedPointer.html#a1e304543bf465355281635c41bb9a542" title="Returns a shared pointer to the pointer held by other, using a dynamic cast to type X to obtain an in...">qSharedPointerDynamicCast()</a> </dd></dl>

</div>
</div>
<a id="a1e304543bf465355281635c41bb9a542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e304543bf465355281635c41bb9a542">&#9670;&nbsp;</a></span>qSharedPointerDynamicCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; qSharedPointerDynamicCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a shared pointer to the pointer held by <em>other</em>, using a dynamic cast to type <code>X</code> to obtain an internal pointer of the appropriate type. </p>
<p>If the <code>dynamic_cast</code> fails, the object returned will be null.</p>
<p>Note that <code>X</code> must have the same cv-qualifiers (<code>const</code> and <code>volatile</code>) that <code>T</code> has, or the code will fail to compile. Use qSharedPointerConstCast to cast away the constness.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#aba5967363a757af57f3dd4fe0e60f1c5" title="Performs a dynamic cast from this pointer&#39;s type to X and returns a QSharedPointer that shares the re...">QSharedPointer::dynamicCast()</a>, <a class="el" href="classQSharedPointer.html#ad19b48288678efcd40caf9fd888bae67" title="Returns a shared pointer to the pointer held by other, cast to type X. ">qSharedPointerCast()</a>, <a class="el" href="classQSharedPointer.html#a28170b45f90c567a4f033f2db54cfd20" title="Returns a shared pointer to the pointer held by other, cast to type X. ">qSharedPointerConstCast()</a> </dd></dl>

</div>
</div>
<a id="abcf22b379b0a44fa2890afc1b4efbd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf22b379b0a44fa2890afc1b4efbd19">&#9670;&nbsp;</a></span>qSharedPointerObjectCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; X &gt; qSharedPointerObjectCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQSharedPointer.html">QSharedPointer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The qSharedPointerObjectCast function is for casting a shared pointer. </p>
<dl class="section since"><dt>Since</dt><dd>4.6</dd></dl>
<p>Returns a shared pointer to the pointer held by <em>other</em>, using a <a class="el" href="qobject_8h.html#a3c5dd82b5bd9f2b683e490f8d26d8caa">qobject_cast()</a> to type <code>X</code> to obtain an internal pointer of the appropriate type. If the <code>qobject_cast</code> fails, the object returned will be null.</p>
<p>Note that <code>X</code> must have the same cv-qualifiers (<code>const</code> and <code>volatile</code>) that <code>T</code> has, or the code will fail to compile. Use qSharedPointerConstCast to cast away the constness.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQSharedPointer.html#a23b65ff3e66fa452957accf732506034" title="Performs a qobject_cast() from this pointer&#39;s type to X and returns a QSharedPointer that shares the ...">QSharedPointer::objectCast()</a>, <a class="el" href="classQSharedPointer.html#ad19b48288678efcd40caf9fd888bae67" title="Returns a shared pointer to the pointer held by other, cast to type X. ">qSharedPointerCast()</a>, <a class="el" href="classQSharedPointer.html#a28170b45f90c567a4f033f2db54cfd20" title="Returns a shared pointer to the pointer held by other, cast to type X. ">qSharedPointerConstCast()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/src/corelib/tools/<a class="el" href="qsharedpointer_8h_source.html">qsharedpointer.h</a></li>
<li>/src/corelib/tools/<a class="el" href="qsharedpointer_8cpp_source.html">qsharedpointer.cpp</a></li>
</ul>
</div><!-- contents -->

<hr class="footer"/><address class="footer"><small><a href="https://dreamswork.github.io/qt4/">Qt 4.8 Source Code Browser</a></small></address>
</body>
</html>
